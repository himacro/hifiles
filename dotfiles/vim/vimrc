" Start {
    source $VIMRUNTIME/vimrc_example.vim
    if $LANG == 'zh_CN' && has('win32') 
    " Chinese for Windows
        set encoding=utf-8
        set langmenu=zh_CN.utf-8
        language messages zh_cn.utf-8
        if has('gui')
            source $VIMRUNTIME/delmenu.vim
            source $VIMRUNTIME/menu.vim
        endif
    endif
" }

" Vundle {
    set nocompatible
    filetype off

    set rtp+=~/.vim/bundle/vundle
    call vundle#rc()

    " Let Vundle manage Vundle {
        Bundle 'gmarik/vundle'
    " }

    " Original repos on github {
        Bundle 'kien/ctrlp.vim'
        Bundle 'majutsushi/tagbar'
        Bundle 'altercation/vim-colors-solarized'
        Bundle 'chriskempson/vim-tomorrow-theme'
        Bundle 'Shougo/neocomplcache'
        Bundle 'Shougo/neosnippet'
        Bundle 'Shougo/vimproc'
        Bundle 'scrooloose/nerdtree'
        Bundle 'scrooloose/nerdcommenter'
        Bundle 'scrooloose/syntastic'
        Bundle 'tpope/vim-fugitive'
        Bundle 'tpope/vim-surround'
        Bundle 'godlygeek/tabular'
        Bundle 'Lokaltog/vim-easymotion'
        Bundle 'Lokaltog/vim-powerline'
        Bundle 'spf13/vim-colors'
        Bundle 'spf13/snipmate-snippets'
        Bundle 'mileszs/ack.vim'
        Bundle 'klen/python-mode'
        Bundle 'xuhdev/SingleCompile'
        Bundle 'jkeylu/vimdoc_cn'
        Bundle 'vim-scripts/cmdline-completion'
        Bundle 'vim-scripts/YankRing.vim'
        Bundle 'himacro/hlasm.vim'
        Bundle 'xolox/vim-session'
        Bundle 'vim-scripts/ZoomWin'
        Bundle 'chrisbra/NrrwRgn'
        Bundle "daylerees/colour-schemes", { "rtp": "vim-themes" }
        " Bundle 'vim-scripts/sessionman.vim'
    " }

    " vim-scripts repos {
        " Bundle 'L9'
    " }

    " non github repos {
        " Bundle 'git://git.wincent.com/command-t.git'
    " }

    filetype plugin indent on
" }
 
" Core settings {
    set encoding=utf-8
    set fileencodings=ucs-bom,utf-8,chinese
    set ambiwidth=double
    set tabstop=4
    set shiftwidth=4
    set softtabstop=4
    set expandtab
    set autoindent
    set smartindent
    set number
    set nowrap
    set incsearch
    set ignorecase
    set backspace=indent,eol,start
    filetype indent plugin on
    syntax enable
    set nobackup
    set showmode
    set ruler
    set helplang=cn
    set foldenable
    set splitbelow
    set splitright
" }

" Colorscheme {
    " solarized setting  {
        if !has('gui') 
            set background=dark
            if $TERM_PALETTE == 'SOLARIZED'
                set t_Co=16
                let g:solarized_termcolors=16
                colorscheme solarized
            elseif &t_Co == 256
                let g:solarized_termcolors=256
                colorscheme solarized
            else
                colorscheme desert
            endif
        endif
    " }
" } 

" plugins {
    " PowerLine {
        set laststatus=2
        " let g:Powerline_symbols = 'fancy'
    " } 

    " neocomplcache {
        let g:acp_enableAtStartup = 0
        let g:neocomplcache_enable_at_startup = 1
        let g:neocomplcache_enable_camel_case_completion = 1
        let g:neocomplcache_enable_smart_case = 1
        let g:neocomplcache_enable_underbar_completion = 1
        let g:neocomplcache_enable_auto_delimiter = 1
        let g:neocomplcache_max_list = 15
        let g:neocomplcache_force_overwrite_completefunc = 1

        " SuperTab like snippets behavior.
        imap <silent><expr><TAB> neosnippet#expandable() ?
                    \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
                    \ "\<C-e>" : "\<TAB>")
        smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)

        " Define dictionary.
        let g:neocomplcache_dictionary_filetype_lists = {
                    \ 'default' : '',
                    \ 'vimshell' : $HOME.'/.vimshell_hist',
                    \ 'scheme' : $HOME.'/.gosh_completions'
                    \ }

        " Define keyword.
        if !exists('g:neocomplcache_keyword_patterns')
            let g:neocomplcache_keyword_patterns = {}
        endif
        let g:neocomplcache_keyword_patterns._ = '\h\w*'

        " Plugin key-mappings.
        " imap <C-k> <Plug>(neosnippet_expand_or_jump)
        " smap <C-k> <Plug>(neosnippet_expand_or_jump)
        inoremap <expr><C-g> neocomplcache#undo_completion()
        inoremap <expr><C-l> neocomplcache#complete_common_string()
        inoremap <expr><CR> neocomplcache#complete_common_string()

        " <TAB>: completion.
        "inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
        "inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<TAB>"

        " <CR>: close popup
        " <s-CR>: close popup and save indent.
        inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup()"\<CR>" : "\<CR>"
        inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>"

        " <C-h>, <BS>: close popup and delete backword char.
        inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
        inoremap <expr><C-y> neocomplcache#close_popup()

        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete

        " Enable heavy omni completion.
        if !exists('g:neocomplcache_omni_patterns')
            let g:neocomplcache_omni_patterns = {}
        endif
        let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'

        " Use honza's snippets.
        " let g:neosnippet#snippets_directory='~/.vim/bundle/snipmate-snippets/snippets'

        " For snippet_complete marker.
        if has('conceal')
            set conceallevel=2 concealcursor=i
        endif

    " }

    " NERDTree {
        " map <C-e> :NERDTreeToggle<CR>:NERDTreeMirror<CR>
        nnoremap <silent> <leader>ff :NERDTreeToggle<CR>:NERDTreeMirror<CR>
        nnoremap <silent> <leader>fl :NERDTreeFind<CR>
        " map <leader>e :NERDTreeFind<CR>
        " nmap <leader>nt :NERDTreeFind<CR>

        let NERDTreeShowBookmarks=1
        let NERDTreeIgnore=['\.pyc', '\~$', '\.swo$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
        let NERDTreeChDirMode=0
        let NERDTreeQuitOnOpen=0
        let NERDTreeMouseMode=2
        let NERDTreeShowHidden=1
        let NERDTreeKeepTreeInNewTab=1
        let g:nerdtree_tabs_open_on_gui_startup=0

    " }
     
    " TagBar {
        nnoremap <silent> <leader>tt :TagbarToggle<CR>
    " }

    " Tabularize {
        nmap <Leader>a& :Tabularize /&<CR>
        vmap <Leader>a& :Tabularize /&<CR>
        nmap <Leader>a= :Tabularize /=<CR>
        vmap <Leader>a= :Tabularize /=<CR>
        nmap <Leader>a: :Tabularize /:<CR>
        vmap <Leader>a: :Tabularize /:<CR>
        nmap <Leader>a:: :Tabularize /:\zs<CR>
        vmap <Leader>a:: :Tabularize /:\zs<CR>
        nmap <Leader>a, :Tabularize /,<CR>
        vmap <Leader>a, :Tabularize /,<CR>
        nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
        vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
    " }

    " Python-mode {
        let g:pymode_lint = 0   " Let Syntastic to do the work
        " let g:pymode_lint_checker='pep8' "pyflakes'
        " let g:pymode_lint_ignore = "E501"
        " let g:pymode_lint_write = 0
        " let g:pymode_lint_cwindow = 1
        " let g:pymode_utils_whitespaces = 1

        if !has('python')
            let g:pymode=1
        endif
    " }

    " Syntastic {
        let g:syntastic_mode_map = { 'mode': 'active',
                                   \ 'active_filetypes': ['c', 'cpp'],
                                   \ 'passive_filetypes': ['python', 'hlasm'] } 
        let g:syntastic_auto_loc_list = 1
        
    " }
    
    " EasyMotion {
    "}
    
    " vim-session {
        let g:session_command_aliases = 1
        set sessionoptions=blank,buffers,curdir,folds,tabpages,resize
    " }

    " YankRing {
        let g:yankring_replace_n_nkey = '<Char-172>'
        let g:yankring_replace_n_pkey = '<Char-174>'
    " }
" }

" key mapping {
    map <C-H> <C-W>h
    map <C-J> <C-W>j
    map <C-K> <C-W>k
    map <C-L> <C-W>l

    nmap <leader>f0 :set foldlevel=0<CR>
    nmap <leader>f1 :set foldlevel=1<CR>
    nmap <leader>f2 :set foldlevel=2<CR>
    nmap <leader>f3 :set foldlevel=3<CR>
    nmap <leader>f4 :set foldlevel=4<CR>
    nmap <leader>f5 :set foldlevel=5<CR>
    nmap <leader>f6 :set foldlevel=6<CR>
    nmap <leader>f7 :set foldlevel=7<CR>
    nmap <leader>f8 :set foldlevel=8<CR>
    nmap <leader>f9 :set foldlevel=9<CR>
" }

" diff mode {
    set diffexpr=MyDiff()
    function! MyDiff()
        let opt = '-a --binary '
        if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
        if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
        let arg1 = v:fname_in
        if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
        let arg2 = v:fname_new
        if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
        let arg3 = v:fname_out
        if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
        let eq = ''
        if $VIMRUNTIME =~ ' '
            if &sh =~ '\<cmd'
                let cmd = '""' . $VIMRUNTIME . '\diff"'
                let eq = '"'
            else
                let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
            endif
        else
            let cmd = $VIMRUNTIME . '\diff'
        endif
        silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
    endf
" }
